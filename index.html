<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Interactive Glitch Shader</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body { margin: 0; overflow: hidden; background: black; }
    canvas { width: 100vw; height: 100vh; display: block; }
    #ui {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      font-family: sans-serif;
      padding: 10px;
      border-radius: 6px;
      z-index: 2;
    }
    label { display: block; margin-top: 5px; font-size: 13px; }
    input[type=range] { width: 150px; }
  </style>
</head>
<body>

<canvas id="glitchCanvas"></canvas>

<div id="ui">
  <label>üéöÔ∏è Glitch Strength: <input id="glitchStrength" type="range" min="0" max="1" step="0.01" value="0.5" /></label>
  <label>üéûÔ∏è Playback Speed (FPS): <input id="fpsControl" type="range" min="1" max="60" value="12" /></label>
</div>

<script id="fragShader" type="x-shader/x-fragment">
precision mediump float;

uniform float u_time;
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform sampler2D u_sprite;
uniform float u_frameIndex;
uniform float u_glitchAmount;
uniform bool u_hasSprite;

float rand(vec2 co) {
  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution.xy;
  vec2 center = u_mouse / u_resolution;

  float dist = distance(uv, center);
  float ripple = sin(dist * 40.0 - u_time * 5.0) * 0.01 * u_glitchAmount;
  float shift = 0.005 * u_glitchAmount + ripple;

  vec3 color;

  if (u_hasSprite) {
    float totalFrames = 36.0;
    float frameWidth = 1.0 / totalFrames;
    float frame = mod(u_frameIndex, totalFrames);
    vec2 spriteUV = uv;
    spriteUV.x = spriteUV.x * frameWidth + frame * frameWidth;

    vec2 offset = vec2(shift, 0.0);
    color.r = texture2D(u_sprite, spriteUV + offset).r;
    color.g = texture2D(u_sprite, spriteUV).g;
    color.b = texture2D(u_sprite, spriteUV - offset).b;

    // Add flicker
    float scan = sin(uv.y * 400.0 + u_time * 20.0);
    color += 0.04 * scan;

    // Add noise
    float noise = rand(uv + u_time);
    color += 0.05 * noise * u_glitchAmount;
  } else {
    // Fallback procedural glitch pattern
    color = vec3(sin(u_time + uv.x * 10.0) * 0.5 + 0.5,
                 sin(u_time + uv.y * 20.0) * 0.5 + 0.5,
                 sin(u_time * 2.0 + uv.x * 15.0) * 0.5 + 0.5);
    color += ripple + rand(uv + u_time) * 0.1;
  }

  gl_FragColor = vec4(color, 1.0);
}
</script>

<script>
const canvas = document.getElementById('glitchCanvas');
const gl = canvas.getContext('webgl');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// UI Elements
const glitchSlider = document.getElementById('glitchStrength');
const fpsSlider = document.getElementById('fpsControl');

// Shader compiler
function compileShader(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    throw new Error(gl.getShaderInfoLog(shader));
  return shader;
}

const vsSource = `
  attribute vec4 a_position;
  void main() {
    gl_Position = a_position;
  }
`;
const fsSource = document.getElementById('fragShader').textContent;

const vertexShader = compileShader(gl.VERTEX_SHADER, vsSource);
const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fsSource);

const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
gl.useProgram(program);

// Quad
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1, -1, 1, -1, -1, 1,
  1, -1, 1, 1, -1, 1
]), gl.STATIC_DRAW);

const positionLoc = gl.getAttribLocation(program, 'a_position');
gl.enableVertexAttribArray(positionLoc);
gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

// Uniforms
const u_time = gl.getUniformLocation(program, 'u_time');
const u_resolution = gl.getUniformLocation(program, 'u_resolution');
const u_mouse = gl.getUniformLocation(program, 'u_mouse');
const u_sprite = gl.getUniformLocation(program, 'u_sprite');
const u_frameIndex = gl.getUniformLocation(program, 'u_frameIndex');
const u_glitchAmount = gl.getUniformLocation(program, 'u_glitchAmount');
const u_hasSprite = gl.getUniformLocation(program, 'u_hasSprite');

let mouse = [0.5 * canvas.width, 0.5 * canvas.height];
canvas.addEventListener('mousemove', e => {
  mouse = [e.clientX, canvas.height - e.clientY];
});
canvas.addEventListener('touchmove', e => {
  if (e.touches[0]) {
    mouse = [e.touches[0].clientX, canvas.height - e.touches[0].clientY];
  }
});

// Texture
const texture = gl.createTexture();
let spriteLoaded = false;
function loadTextureFrom(src) {
  const image = new Image();
  image.crossOrigin = "anonymous";
  image.onload = () => {
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    spriteLoaded = true;
  };
  image.onerror = () => {
    console.warn("Failed to load sprite sheet from", src);
    spriteLoaded = false;
  };
  image.src = src;
}

// Attempt IPFS, fallback to local
loadTextureFrom("https://ipfs.io/ipfs/bafybeif2w45idnidckunfp2yp7o6vezc4zejbgc7ylfrpxfz6qyjj4hboi");
setTimeout(() => {
  if (!spriteLoaded) loadTextureFrom("spriteSheet2.png");
}, 3000);

// Animation
let start = performance.now();
function render(now) {
  const t = (now - start) / 1000;
  const fps = parseFloat(fpsSlider.value);
  const frame = Math.floor(t * fps);
  const glitchAmount = parseFloat(glitchSlider.value);

  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.clear(gl.COLOR_BUFFER_BIT);

  gl.uniform1f(u_time, t);
  gl.uniform1f(u_frameIndex, frame);
  gl.uniform2f(u_resolution, canvas.width, canvas.height);
  gl.uniform2f(u_mouse, mouse[0], mouse[1]);
  gl.uniform1f(u_glitchAmount, glitchAmount);
  gl.uniform1i(u_hasSprite, spriteLoaded ? 1 : 0);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.uniform1i(u_sprite, 0);

  gl.drawArrays(gl.TRIANGLES, 0, 6);
  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>
</body>
</html>
